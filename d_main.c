// Emacs style mode select   -*- C++ -*- 
//-----------------------------------------------------------------------------
//
// $Id:$
//
// Copyright (C) 1993-1996 by id Software, Inc.
//
// This source is available for distribution and/or modification
// only under the terms of the DOOM Source Code License as
// published by id Software. All rights reserved.
//
// The source is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License
// for more details.
//
// $Log:$
//
// DESCRIPTION:
//	DOOM main program (D_DoomMain) and game loop (D_DoomLoop),
//	plus functions to determine game mode (shareware, registered),
//	parse command line parameters, configure game parameters (turbo),
//	and call the startup functions.
//
//-----------------------------------------------------------------------------


static const char rcsid[] = "$Id: d_main.c,v 1.8 1997/02/03 22:45:09 b1 Exp $";

#include <windows.h>
#include <gl/gl.h>

#define	BGCOLOR		7
#define	FGCOLOR		8

#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#ifdef NORMALUNIX
#include <unistd.h>
#endif

#include <direct.h>
#include <malloc.h>
#include <io.h>


#include "doomdef.h"
#include "doomstat.h"

#include "dstrings.h"
#include "sounds.h"


#include "z_zone.h"
#include "w_wad.h"
#include "s_sound.h"
#include "v_video.h"

#include "f_finale.h"
#include "f_wipe.h"

#include "m_argv.h"
#include "m_misc.h"
#include "m_menu.h"

#include "i_system.h"
#include "i_sound.h"
#include "i_video.h"

#include "g_game.h"

#include "hu_stuff.h"
#include "wi_stuff.h"
#include "st_stuff.h"
#include "am_map.h"

#include "p_setup.h"
#include "r_local.h"


#include "d_main.h"

#include "d_console.h"
#include "gldefs.h"
#include "gconsole.h"
#include "gl_video.h"
#include "doomlib.h"

void WS_Init(void);
void LoadAllSprites(void);

void CreateGLPalette(void);

dboolean bShowTitle = false;

void lfprintf(char *message, ... );

//
// D-DoomLoop()
// Not a globally visible function,
//  just included for source reference,
//  called by D_DoomMain, never exits.
// Manages timing and IO,
//  calls all ?_Responder, ?_Ticker, and ?_Drawer,
//  calls I_GetTime, I_StartFrame, and I_StartTic
//

void D_DoomLoop (void);

extern GLTexData  glTitlePic[2], glHelp[2], glHelp1[2], glCredit[2], glHelp2[2];
GLTexData  *glPageName;

void WI_Init(void);
void F_Init(void);

char*		wadfiles[MAXWADFILES];

char        gamename[128] = "";
dboolean		devparm;	// started game with -devparm
dboolean         nomonsters;	// checkparm of -nomonsters
dboolean         respawnparm;	// checkparm of -respawn
dboolean         fastparm;	// checkparm of -fast

dboolean         drone;

dboolean		singletics = false; // debug flag to cancel adaptiveness

extern dboolean plutonia, tnt;

//extern int soundVolume;
//extern  int	sfxVolume;
//extern  int	musicVolume;

extern  dboolean	inhelpscreens;

extern  int     loadtime;

skill_t		startskill;
int             startepisode;
int		startmap;
dboolean		autostart;

FILE*		debugfile;

dboolean		advancedemo;


extern      int nosound, nosound_t;

char		wadfile[1024];		// primary wad file
char		mapdir[1024];           // directory of development maps
char		basedefault[1024];      // default file


void D_CheckNetGame (void);
void D_ProcessEvents (void);
void G_BuildTiccmd (ticcmd_t* cmd);
void D_DoAdvanceDemo (void);

int  PauseTex;
int  PauseHigh, PauseWide;

//
// EVENT HANDLING
//
// Events are asynchronous inputs generally generated by the game user.
// Events can be discarded if no responder claims them
//
event_t         events[MAXEVENTS];
int             eventhead;
int             eventtail;

//
// D_PostEvent
// Called by the I/O functions when input is detected
//
void D_PostEvent (event_t* ev)
   {
    events[eventhead] = *ev;
    eventhead = (++eventhead)&(MAXEVENTS-1);
   }


//
// D_ProcessEvents
// Send all the events of the given timestamp down the responder chain
//

void D_ProcessEvents (void)
   {
    event_t*	ev;
    // IF STORE DEMO, DO NOT ACCEPT INPUT
    if (( gamemode == commercial ) && (W_CheckNumForName("map01")<0))
        return;
	
    for (; eventtail != eventhead; eventtail = (++eventtail)&(MAXEVENTS-1))
       {
        ev = &events[eventtail];
        if (CO_Responder(ev))
           {
            continue;               // console ate the event
           }
        if (M_Responder(ev))
           {
            continue;               // menu ate the event
           }
        G_Responder(ev);
       }
   }




//
// D_Display
//  draw current display, possibly wiping it from the previous
//

void GL_DrawFullScreen(GLTexData *Image);

void GL_RenderPlayerView(player_t *player);
void GL_DrawStatusBar(int);
void GL_DrawPausePic(void);
void GL_DrawConsole(void);
void GL_AM_Drawer(void);
void GL_HU_Drawer(void);
void GL_WI_Drawer(void);
void GL_F_Drawer(void);
void GL_DrawMenu(void);

extern glmode_t glmode;

// wipegamestate can be set to -1 to force a wipe on the next draw
gamestate_t     wipegamestate = GS_DEMOSCREEN;
extern  dboolean setsizeneeded;
extern  int             showMessages;
void R_ExecuteSetViewSize (void);
extern  int             hudmode;

void D_Display (void)
   {
    static  dboolean		viewactivestate = false;
    static  dboolean		menuactivestate = false;
    static  dboolean		inhelpscreensstate = false;
    static  dboolean		fullscreen = false;
    static  gamestate_t		oldgamestate = -1;
    static  int			borderdrawcount;
    int				nowtime;
    int				tics;
    int				wipestart;
    dboolean			done;
    dboolean			wipe;
    dboolean			redrawsbar;

    if (nodrawers)
        return;                    // for comparative timing / profiling
		
    redrawsbar = false;
    
    // change the view size if needed
    if (setsizeneeded)
       {
        R_ExecuteSetViewSize ();
        oldgamestate = -1;                      // force background redraw
        borderdrawcount = 3;
       }

    // save the current screen if about to wipe
    if (gamestate != wipegamestate)
       {
        wipe = true;
        wipe_StartScreen(0, 0, SCREENWIDTH, SCREENHEIGHT);
       }
    else
       wipe = false;

    if (gamestate == GS_LEVEL && gametic)
       {
        HU_Erase();
       }
    
    // do buffered drawing
    switch (gamestate)
       {
        case GS_LEVEL:
             if (!gametic)
                 break;
             if (automapactive)
                {
                 AM_Drawer ();
                 GL_AM_Drawer();
                 GL_DrawStatusBar(1);
                }
             if (wipe || (viewheight != SCREENHEIGHT && fullscreen) )
                 redrawsbar = true;
             if (inhelpscreensstate && !inhelpscreens)
                 redrawsbar = true;              // just put away the help screen
             ST_Drawer(viewheight == SCREENHEIGHT, redrawsbar );
             fullscreen = viewheight == SCREENHEIGHT;
             if (!automapactive)
                {
                 R_RenderPlayerView (&players[displayplayer]);
                 GL_RenderPlayerView (&players[displayplayer]);
                }
             break;

        case GS_INTERMISSION:
             WI_Drawer();
             GL_WI_Drawer();
             break;

        case GS_FINALE:
             F_Drawer();
             GL_F_Drawer();
             break;

        case GS_DEMOSCREEN:
             D_PageDrawer();
             GL_DrawFullScreen(glPageName);
             break;
       }
    
    // draw buffered stuff to screen
    I_UpdateNoBlit();
    
    // draw the view directly
    if (gamestate == GS_LEVEL && !automapactive && gametic)
       {
        R_RenderPlayerView (&players[displayplayer]);
        //GL_RenderPlayerView (&players[displayplayer]);
        GL_DrawStatusBar(hudmode);
       }

    glColor4f(1.0f, 1.0f, 1.0f, 1.0f);

    if (gamestate == GS_LEVEL && gametic)
       {
        HU_Drawer ();
        GL_HU_Drawer();
       }
    
    // clean up border stuff
    if (gamestate != oldgamestate && gamestate != GS_LEVEL)
       {
        I_SetPalette (W_CacheLumpName ("PLAYPAL",PU_CACHE));
       }

    // see if the border needs to be initially drawn
    if (gamestate == GS_LEVEL && oldgamestate != GS_LEVEL)
       {
        viewactivestate = false;        // view was not active
        R_FillBackScreen ();    // draw the pattern into the back screen
       }

    // see if the border needs to be updated to the screen
    if (gamestate == GS_LEVEL && !automapactive && scaledviewwidth != SCREENWIDTH && viewheight != SCREENHEIGHT)
       {
        if (menuactive || menuactivestate || !viewactivestate)
            borderdrawcount = 3;
        if (borderdrawcount)
           {
            R_DrawViewBorder();    // erase old menu stuff
            borderdrawcount--;
           }
       }

    menuactivestate = menuactive;
    viewactivestate = viewactive;
    inhelpscreensstate = inhelpscreens;
    oldgamestate = wipegamestate = gamestate;

    // draw pause pic
    if (paused)
       {
        GL_DrawPausePic();
/*
        if (automapactive)
            y = 4;
        else
            y = viewwindowy+4;
        V_DrawPatchDirect(viewwindowx+(scaledviewwidth-68)/2,y,0,W_CacheLumpName ("M_PAUSE", PU_CACHE));
*/
       }
    // menus go directly to the screen
    M_Drawer ();          // menu is drawn even on top of everything

    glmode = gl_2d;

    GL_DrawMenu();

    if (bConsoleActive == true)
       {
        GL_DrawConsole();
       }
    //CO_Drawer();          // Console is drawn on top of even the menu...
    NetUpdate ();         // send out any new accumulation

// FIXME... This disables the screen wipe... (I think)
    wipe = false;

    // normal update
    if (!wipe)
       {
        I_FinishUpdate ();              // page flip or blit buffer
        return;
       }
    
    // wipe update
    wipe_EndScreen(0, 0, SCREENWIDTH, SCREENHEIGHT);

    wipestart = I_GetTime () - 1;
    do
       {
        do
           {
            nowtime = I_GetTime ();
            tics = nowtime - wipestart;
           }
        while(!tics);
        wipestart = nowtime;
        done = wipe_ScreenWipe(wipe_Melt, 0, 0, SCREENWIDTH, SCREENHEIGHT, tics);
        I_UpdateNoBlit ();
        M_Drawer ();                            // menu is drawn even on top of wipes
        //CO_Drawer();                            // Console is drawn on top of even the menu...
        I_FinishUpdate ();                      // page flip or blit buffer
       }
    while(!done);
   }

GLTexData PauseTexData;
extern int TexWide, TexHigh;

/*
void GL_PauseInit()
   {
    patch_t *PausePatch;

    PausePatch = W_CacheLumpName("M_PAUSE", PU_CACHE);
    PauseTexData.TexName = PauseTex;
    PauseTexData.Width = PausePatch->width;
    PauseTexData.Height = PausePatch->height;
    PauseTexData.XDisp = (float)PausePatch->width / (float)TexWide;
    PauseTexData.YDisp = 1.0f - ((float)PausePatch->height / (float)TexHigh);
   }
*/

extern float SetBack;

void GL_DrawPausePic()
   {
    float PauseLeft, PauseRight, PauseBottom;

    glEnable(GL_TEXTURE_2D);
    glEnable(GL_ALPHA_TEST);
    glAlphaFunc(GL_GREATER, 0.0f);

    PauseLeft = PauseTexData.Width / -2.0f;
    PauseRight = PauseTexData.Width / 2.0f;
    PauseBottom = 116.0f - PauseTexData.Height;

    glColor3f( 1.0f, 1.0f, 1.0f );
    glBindTexture(GL_TEXTURE_2D, PauseTex);
    glBegin( GL_QUADS );
      glNormal3f( 0.0f, 0.0f, 1.0f);
      glTexCoord2f( 0.0f, 1.0f );
      glVertex3f( PauseLeft,  116.0f, SetBack );
      glTexCoord2f( 0.0f, PauseTexData.YDisp );
      glVertex3f( PauseLeft, PauseBottom, SetBack );
      glTexCoord2f( PauseTexData.XDisp, PauseTexData.YDisp );
      glVertex3f( PauseRight, PauseBottom, SetBack);
      glTexCoord2f( PauseTexData.XDisp, 1.0f );
      glVertex3f( PauseRight, 116.0f, SetBack);
    glEnd();

    glDisable(GL_ALPHA_TEST);
    glDisable(GL_TEXTURE_2D);
   }

//
//  D_DoomLoop
//
extern  int             demotype;
extern  dboolean         demorecording;

void D_DoomLoop (void)
   {
    if (demorecording)
        G_BeginRecording ();
		
    if (M_CheckParm ("-debugfile"))
       {
        char    filename[20];
        sprintf (filename,"debug%i.txt",consoleplayer);
	    //printf ("debug output to: %s\n",filename);
        lfprintf("debug output to: %s\n",filename);
        debugfile = fopen (filename,"w");
       }
	
    I_InitGraphics();

    while (1)
       {
        // frame syncronous IO operations
        I_StartFrame();                
	
        // process one or more tics
        if (singletics)
           {
            I_StartTic ();
            D_ProcessEvents ();
            G_BuildTiccmd (&netcmds[consoleplayer][maketic%BACKUPTICS]);
            if (advancedemo)
               D_DoAdvanceDemo();
            M_Ticker ();
            G_Ticker ();
            gametic++;
            maketic++;
           }
        else
           {
            TryRunTics (); // will run at least one tic
           }
		
        S_UpdateSounds (players[consoleplayer].mo);// move positional sounds

        // Update display, next frame, with current state.
        D_Display ();

#ifndef SNDSERV
        // Sound mixing for the buffer is snychronous.
        //I_UpdateSound();
#endif	
        // Synchronous sound output is explicitly called.
#ifndef SNDINTR
        // Update sound output.
        //I_SubmitSound();
#endif
       }
   }

void MY_DoomSetup(void)
   {
    if (demorecording)
        G_BeginRecording ();
		
    if (M_CheckParm ("-debugfile"))
       {
        char    filename[20];
        sprintf (filename,"debug%i.txt",consoleplayer);
	    //printf ("debug output to: %s\n",filename);
        lfprintf("debug output to: %s\n",filename);
        debugfile = fopen (filename,"w");
       }
    I_SetPalette (W_CacheLumpName("PLAYPAL", PU_CACHE));
    //CreateGLPalette();
   }

void MY_DoomLoop (void)
   {
    // frame syncronous IO operations
    I_StartFrame();
	
    // process one or more tics
    if (singletics)
       {
        I_StartTic();
        D_ProcessEvents();
        G_BuildTiccmd (&netcmds[consoleplayer][maketic%BACKUPTICS]);
        if (advancedemo)
           {
            D_DoAdvanceDemo();
           }
        CO_Ticker();
        M_Ticker();
        G_Ticker();
        gametic++;
        maketic++;
       }
    else
       {
        TryRunTics(); // will run at least one tic
       }
	
    S_UpdateSounds (players[consoleplayer].mo);// move positional sounds
    // Update display, next frame, with current state.
    D_Display();

#ifndef SNDSERV
    // Sound mixing for the buffer is snychronous.
    //I_UpdateSound();
#endif	
    // Synchronous sound output is explicitly called.
#ifndef SNDINTR
    // Update sound output.
    //I_SubmitSound();
#endif
   }



//
//  DEMO LOOP
//
int             demosequence;
int             pagetic;
char                    *pagename;


//
// D_PageTicker
// Handles timing for warped projection
//
void D_PageTicker (void)
{
    if (--pagetic < 0)
	D_AdvanceDemo ();
}



//
// D_PageDrawer
//
void D_PageDrawer (void)
{
    int i;
    __int64 *d;

    d = (__int64 *)screens[0];
    for (i = 0; i < ((SCREENWIDTH*SCREENHEIGHT)/8); i++)
       d[i] = 0;

    V_DrawPatch (((SCREENWIDTH-320)/2),((SCREENHEIGHT-200)/2), 0, W_CacheLumpName(pagename, PU_CACHE));
}

void GL_DrawFullScreen(GLTexData *Image);

void GL_PageDrawer (void)
   {
    GL_DrawFullScreen(glPageName);
   }


//
// D_AdvanceDemo
// Called after each demo or intro demosequence finishes
//
void D_AdvanceDemo (void)
{
    advancedemo = true;
}


//
// This cycles through the demo sequences.
// FIXME - version dependend demo numbers?
//
 void D_DoAdvanceDemo (void)
   {
    players[consoleplayer].playerstate = PST_LIVE;  // not reborn
    advancedemo = false;
    usergame = false;               // no save / end game here
    paused = false;
    gameaction = ga_nothing;

    if ( gamemode == retail )
        demosequence = (demosequence+1)%7;
    else
        demosequence = (demosequence+1)%6;
    
    bShowTitle = false;

    switch (demosequence)
       {
        case 0:
             if ( gamemode == commercial )
                 pagetic = 35 * 11;
             else
                 pagetic = 170;
             gamestate = GS_DEMOSCREEN;
             pagename = "TITLEPIC";
             glPageName = glTitlePic;
             if ( gamemode == commercial )
                 S_StartMusic(mus_dm2ttl);
             else
                 S_StartMusic (mus_intro);
             bShowTitle = true;
             break;
        case 1:
             G_DeferedPlayDemo ("demo1");
             break;
        case 2:
             pagetic = 200;
             gamestate = GS_DEMOSCREEN;
             pagename = "CREDIT";
             glPageName = glCredit;
             bShowTitle = true;
             break;
        case 3:
             G_DeferedPlayDemo("demo2");
             break;
        case 4:
             gamestate = GS_DEMOSCREEN;
             if ( gamemode == commercial)
                {
                 pagetic = 35 * 11;
                 pagename = "TITLEPIC";
                 glPageName = glTitlePic;
                 S_StartMusic(mus_dm2ttl);
                }
             else
                {
                 pagetic = 200;
                 if ( gamemode == retail )
                    {
                     pagename = "CREDIT";
                     glPageName = glCredit;
                    }
                 else
                    {
                     pagename = "HELP2";
                     glPageName = glHelp2;
                    }
                }
             bShowTitle = true;
             break;
        case 5:
             G_DeferedPlayDemo ("demo3");
             break;
        // THE DEFINITIVE DOOM Special Edition demo
        case 6:
             G_DeferedPlayDemo ("demo4");
             break;
       }
   }



//
// D_StartTitle
//
void D_StartTitle (void)
{
    gameaction = ga_nothing;
    demosequence = -1;
    D_AdvanceDemo ();
}

//      print title for every printed line
char            title[128];

//
// D_AddFile
//
void D_AddFile (char *file)
{
    int     numwadfiles;
    char    *newfile;
	
    for (numwadfiles = 0 ; wadfiles[numwadfiles] ; numwadfiles++)
	;

    newfile = malloc (strlen(file)+1);
    strcpy (newfile, file);
	
    wadfiles[numwadfiles] = newfile;
}

// gets the filename from the pathname (extension included)
char *dirname(char *pathname)
   {
    char    *c;
    static   char tpath[_MAX_PATH];

    strcpy(tpath, pathname);
    if ((c = strrchr(tpath, '\\')) != NULL)
       {
        c++;
        *c = '\0';
       }
    else
    if ((c = strrchr(tpath, '/')) != NULL)
       {
        c++;
        *c = '\0';
       }
    else
       {
        strcat(tpath, "/");
       }
    return tpath;
   }

// gets the filename from the pathname (extension included)
char *basename(char *pathname)
   {
    char *c;

    if ((c = strrchr(pathname, '\\')) != NULL)
       {
        return(c+1);
       }
    if ((c = strrchr(pathname, '/')) != NULL)
       {
        return(c+1);
       }
    return pathname;
   }

// gets the file name without the file extension
char *noext(char *pathname)
   {
    static char tstr[_MAX_PATH];
    int   i;
    char *c;

    if ((c = strrchr(pathname, '.')) != NULL)
       {
        i = (c - pathname);
        strncpy(tstr, pathname, i);
        tstr[i] = '\0';
        return(tstr);
       }
    else
       {
        return(pathname);
       }
   }


dboolean CheckGameMode()
   {
    char name[10];
    int  e, m;
    dboolean bValid;


    e = W_CheckNumForName("playpal");

    con_printf("Determining game mode...\n");
    con_printf("Checking for Doom 2/Final Doom...\n");
    // check for Doom2/Final Doom lumps here
    for (m = 1, bValid = true; m < 33; m++)
       {
        sprintf(name, "MAP%02d", m);
        if (W_CheckNumForName(name) < 0)
           {
            bValid = false;
            break;
           }
       }
    if ((bValid == false) && (m == 31))
       {
        // This may be the German version of Doom2 - No Wolfenstein stuff
        bValid = true;
       }

    if ((bValid == true) && (W_CheckNumForName("interpic") >= 0))
       {
        gamemode = commercial;
        return true;
       }
    if (gamemode == commercial)
       {
        con_printf("HEY! - This is NOT Doom 2 or Final Doom!!!\n");
       }

    con_printf("Checking for Ultimate Doom...\n");
    // check for Ultimate Doom lumps here
    for (e = 4, m = 1, bValid = true; m < 10; m++)
       {
        sprintf(name, "E%dM%d", e, m);
        if (W_CheckNumForName(name) < 0)
           {
            bValid = false;
            break;
           }
       }
    if ((bValid == true) && 
        (W_CheckNumForName("dphoof") >= 0) &&
        (W_CheckNumForName("bfgga0") >= 0) &&
        (W_CheckNumForName("heada1") >= 0) &&
        (W_CheckNumForName("cybra1") >= 0) &&
        (W_CheckNumForName("spida1d1") >= 0) &&
        (W_CheckNumForName("m_epi4") >= 0))
       {
        gamemode = retail;
        return true;
       }
    if (gamemode == retail)
       {
        con_printf("HEY! - This is NOT Ultimate Doom!!!\n");
       }


    con_printf("Checking for Registered Doom...\n");
    // check for Registered Doom lumps here
    for (e = 2, bValid = true; ((e < 4) && (bValid == true)); e++)
       {
        for (m = 1; m < 10; m++)
           {
            sprintf(name, "E%dM%d", e, m);
            if (W_CheckNumForName(name) < 0)
               {
                bValid = false;
                break;
               }
           }
       }
    if ((bValid == true) && 
        (W_CheckNumForName("dphoof") >= 0) &&
        (W_CheckNumForName("bfgga0") >= 0) &&
        (W_CheckNumForName("heada1") >= 0) &&
        (W_CheckNumForName("cybra1") >= 0) &&
        (W_CheckNumForName("spida1d1") >= 0))
       {
        gamemode = registered;
        return true;
       }

    if (gamemode == registered)
       {
        con_printf("HEY! - This is NOT the REGISTERED version of Doom!!!\n");
       }

    con_printf("Checking for Shareware Doom...\n");
    // check for shareware lumps here
    for (e = 1, m = 1, bValid = true; m < 10; m++)
       {
        sprintf(name, "e%dm%d", e, m);
        if (W_CheckNumForName(name) < 0)
           {
            bValid = false;
           }
       }
    if ((bValid == true) &&
        (W_CheckNumForName("m_epi1") >= 0) &&
        (W_CheckNumForName("m_epi2") >= 0) &&
        (W_CheckNumForName("m_epi3") >= 0))
       {
        gamemode = shareware;
        return true;
       }
    if (gamemode == registered)
       {
        con_printf("HEY! - This isn't even the SHAREWARE version of Doom!!!\n");
       }

    gamemode = undetermined;
    return false;
   }

typedef enum
   {
    gw_doomfr,
    gw_commercial,
    gw_tnt,
    gw_plutonia,
    gw_retail,
    gw_registered,
    gw_shareware,
    gw_other
   }gamewad_t;

int  iGameModes[] = { commercial, commercial, commercial, commercial, retail, registered, shareware };
int  iLanguages[] = { french, english, english, english, english, english, english };
char *szWadNames[] = { "doom2f", "doom2", "tnt", "plutonia", "doomu", "doom", "doom1" };
char *szGameNames[] = { "Doom 2 - French",  // Not francaise - we speak ENGLISH here...
                        "Doom 2",
                        "Final Doom - TnT",
                        "Final Doom - Plutonia Experiment",
                        "Ultimate Doom",
                        "Registered Doom",
                        "Shareware Doom" };


struct _finddata_t finddata;
long   search_handle;

char *D_FindFirst( char *filespec )
   {
    if ((search_handle = _findfirst( filespec, &finddata)) != -1)
       {
        return finddata.name;
       }
    else
       {
        return NULL;
       }
   }

char *D_FindNext()
   {
    if (_findnext(search_handle, &finddata) != -1)
       {
        return finddata.name;
       }
    else
       {
        return NULL;
       }
   }

//
// IdentifyVersion
// Checks availability of IWAD files by name,
// to determine whether registered/commercial features
// should be executed (notably loading PWAD's).
//
void IdentifyVersion (void)
   {
    char    doomwad[_MAX_PATH], *c;
    char   *doomwaddir, id[4];
    int     i;
    struct  _stat buf;
    FILE   *fh;

#ifdef NORMALUNIX
    char   *home;

    home = getenv("HOME");
    if (!home)
        I_Error("Please set $HOME to your home directory");

    sprintf(basedefault, "%s/.doomrc", home);
#endif

    i = M_CheckParm("-game");
    if (i && (i < (myargc-1)))
       {
        strcpy(gamename, myargv[i+1]);
        sprintf(doomwad, "%s.wad", noext(basename(gamename)));
        if (_access(doomwad, R_OK))
           {
            _stat(gamename, &buf);
            if (buf.st_mode & _S_IFDIR)
               {
                con_printf("-game points to a directory [%s]\n", gamename);
                sprintf(doomwad, "%s*.wad", dirname(gamename));
                gamename[0] = '\0';
                if ((c = D_FindFirst(doomwad)) != NULL)
                   {
                    strcpy(doomwad, c);
                    if ((fh = fopen(doomwad, "rb")) != NULL)
                       {
                        fread(id, 4, 1, fh);
                        fclose(fh);
                        if (strncmp(id, "IWAD", 4) != 0)
                           {
                            while ((c = D_FindNext()) != NULL)
                               {
                                strcpy(doomwad, c);
                                if ((fh = fopen(doomwad, "rb")) != NULL)
                                   {
                                    fread(id, 4, 1, fh);
                                    fclose(fh);
                                    if (strncmp(id, "IWAD", 4) == 0)
                                       {
                                        strcpy(gamename, c);
                                        break;
                                       }
                                   }
                               }
                           }
                        else
                           {
                            strcpy(gamename, c);
                           }
                       }
                   }
                if (strlen(gamename) > 0)
                   {
                    con_printf("Found IWAD [%s]...\n", gamename);
                   }
                else
                   {
                    con_printf("No IWAD's found in directory [%s]...\n");
                   }
               }
           }
        else
           {
            con_printf("Loading game wad: %s\n", gamename);
           }
       }

    if (strlen(gamename) > 0)
       {
        // check the specified game WAD against the standard WAD names
        for (i = 0; i < gw_other; i++)
           {
            if (D_strcasecmp(noext(basename(gamename)), szWadNames[i]) == 0)
               {
                // append ".wad" to the file if it doesn't have an extension
                if (strcmp(gamename, noext(gamename)) == 0)
                   {
                    strcat(gamename, ".wad");
                   }
                // found a matching wad name - check to see if it exists
                if (!_access(gamename, R_OK))
                   {
                    // found a WAD and it exists. Let's use it. 
                    con_printf("Game mode %s selected\n", szGameNames[i]);
                    gamemode = iGameModes[i];
                    D_AddFile(gamename);
                    return;
                   }
                else
                   {
                    con_printf("Wad does not exist. Checking standard WADs\n");
                    break;
                   }
               }
           }
       }

    if (strlen(gamename) > 0)
       {
        con_printf("Standard game not specified - checking.\n");
        if (!_access(gamename, R_OK))
           {
            con_printf("Wad file exists determining \"mode\"...\n");
            D_AddFile(gamename);
            gamemode = undetermined;
            conversion = true;
            return;
           }
        con_printf("Wad file does not exist. Checking standard WADs\n");
       }
    else
       {
        con_printf("No game wad specified - looking for standard WADs...\n");
       }

    doomwaddir = getenv("DOOMWADDIR");
    if (!doomwaddir)
       {
        doomwaddir = getenv("DOOMDIR");
       }
    if (!doomwaddir)
        doomwaddir = ".";

    for (i = 0; i < gw_other; i++)
       {
        sprintf(doomwad, "%s/%s.wad", doomwaddir, szWadNames[i]);
        if ( !_access(doomwad,R_OK) )
           {
            con_printf("Found game WAD for: %s\n", szGameNames[i]);
            strcpy(gamename, szWadNames[i]);
            gamemode = iGameModes[i];
            language = iLanguages[i];
            D_AddFile(doomwad);
            return;
           }
       }

/*
    if (M_CheckParm ("-shdev"))
       {
        gamemode = shareware;
        devparm = true;
        D_AddFile (DEVDATA"doom1.wad");
        D_AddFile (DEVMAPS"data_se/texture1.lmp");
        D_AddFile (DEVMAPS"data_se/pnames.lmp");
        strcpy (basedefault,DEVDATA"default.cfg");
        return;
       }

    if (M_CheckParm ("-regdev"))
       {
        gamemode = registered;
        devparm = true;
        D_AddFile (DEVDATA"doom.wad");
        D_AddFile (DEVMAPS"data_se/texture1.lmp");
        D_AddFile (DEVMAPS"data_se/texture2.lmp");
        D_AddFile (DEVMAPS"data_se/pnames.lmp");
        strcpy (basedefault,DEVDATA"default.cfg");
        return;
       }

    if (M_CheckParm ("-comdev"))
       {
        gamemode = commercial;
        devparm = true;
        D_AddFile (DEVDATA"doom2.wad");
        D_AddFile (DEVMAPS"cdata/texture1.lmp");
        D_AddFile (DEVMAPS"cdata/pnames.lmp");
        strcpy (basedefault,DEVDATA"default.cfg");
        return;
       }
*/
}

// This function processes text lines and
// removes 'C' style comments as well as
// Bourne/Korn shell style comments '#',
// leading white space, trailing white space
// and trailing newline characters.

char *D_PrepTextLine( char *text )
   {
    char   *c, *t;

    // trim off trailing white space or new lines
    t = &text[strlen(text)-1];
    while ((*t == ' ') || (*t == '\t') || (*t == '\n') || (*t == '\r'))
       {
        *t = '\0';
        t--;
       }

    // trim off commented out sections
    c = text;
    while (*c)
       {
        // look for Bourne/Korn shell style comments
        if (*c == '#')
           {
            *c = '\0';
            break;
           }
        else
        // look for ANSI C or C++ style comments
        if (*c == '/')
           {
            c++;
            if (*c == '/')
               {
                *c = '\0';
                break;
               }
            else
            if (*c == '\0')
               {
                break;
               }
           }
        c++;
       }

    // trim off leading "white space"
    c = text;
    while (((*c == ' ') || (*c == '\t')) && (*c))
       {
        c++;
       }

    return(c);
   }

char readline[256];

//
// Find a Response File
//
void FindResponseFile(void)
   {
    int             i;

    for (i = 1;i < myargc;i++)
       {
        if (myargv[i][0] == '@')
           {
            FILE   *handle;
            char   *linetext;
            char   *arg;
        
            handle = fopen (&myargv[i][1],"rb");
            if (!handle)
               {
                con_printf ("Response file [%s] doesn't exist...\n", &myargv[i][1]);
                return;
               }
            con_printf("Found response file %s!\n", &myargv[i][1]);
            while (fgets(readline, 255, handle) != NULL)
               {
                linetext = D_PrepTextLine(readline);
                if (strlen(linetext) == 0)
                   {
                    break;
                   }
                if ((arg = strtok(linetext, " ")) != NULL)
                   {
                    M_AddParm(arg);
                    while ((arg = strtok(NULL, " ")) != NULL)
                       {
                        M_AddParm(arg);
                       }
                   }
               }
            break;
           }
       }
   }

//
// D_DoomMain
//
void D_DoomMain (void)
   {
    int             p;
    char                    file[256];
    byte           *demover;

    //FindResponseFile();
	
    con_printf("M_loadDefaults: Load system defaults.\n");
    M_LoadDefaults (); // load before initing other systems

    IdentifyVersion();

    if (gamemode == undetermined)
       {
        return;
       }
	
    if (D_strcasecmp(noext(basename(gamename)), "tnt") == 0)
       {
        tnt = true;
        plutonia = false;
       }

    if (D_strcasecmp(noext(basename(gamename)), "plutonia") == 0)
       {
        tnt = false;
        plutonia = true;
       }

    setbuf(stdout, NULL);
    modifiedgame = false;

    nomonsters  = M_CheckParm ("-nomonsters");
    respawnparm = M_CheckParm ("-respawn");
    fastparm    = M_CheckParm ("-fast");
    devparm     = M_CheckParm ("-devparm");

    deathmatch = 0;
    if (M_CheckParm ("-altdeath"))
       {
	    deathmatch = 2;
       }
    else
    if (M_CheckParm ("-deathmatch"))
       {
        deathmatch = 1;
       }

    if (devparm)
        con_printf(D_DEVSTR);
    
    if (M_CheckParm("-cdrom"))
       {
        con_printf(D_CDROM);
        //mkdir("c:\\doomdata",0); // What's the ",0" for? Oh yeah, permissions...
        _mkdir("c:\\doomdata");
        strcpy (basedefault,"c:/doomdata/default.cfg");
       }	
    
    // turbo option
    if ( (p = M_CheckParm ("-turbo")) )
       {
        int     scale = 200;
        extern int forwardmove[2];
        extern int sidemove[2];
	
        if (p < myargc-1)
            scale = atoi (myargv[p+1]);
        if (scale < 10)
            scale = 10;
        if (scale > 400)
            scale = 400;
        //printf ("turbo scale: %i%%\n",scale);
        forwardmove[0] = forwardmove[0]*scale/100;
        forwardmove[1] = forwardmove[1]*scale/100;
        sidemove[0] = sidemove[0]*scale/100;
        sidemove[1] = sidemove[1]*scale/100;
       }

    // Add the glDoom PWAD that contains the new resources...
    D_AddFile("./glDoom.wad");
    
    // add any files specified on the command line with -file wadfile
    // to the wad list
    //
    // convenience hack to allow -wart e m to add a wad file
    // prepend a tilde to the filename so wadfile will be reloadable
    p = M_CheckParm ("-wart");
    if (p)
       {
	    myargv[p][4] = 'p';     // big hack, change to -warp
        file[0] = '\0';

	    // Map name handling.
	    switch (gamemode )
	       {
	        case shareware:
	        case retail:
	        case registered:
                 if (p < myargc-2)
                    {
                     sprintf (file,"~"DEVMAPS"E%cM%c.wad", myargv[p+1][0], myargv[p+2][0]);
	                 lfprintf("Warping to Episode %s, Map %s.\n", myargv[p+1],myargv[p+2]);
                    }
	             break;
	    
	        case commercial:
	        default:
                 if (p < myargc-1)
                    {
                     p = atoi (myargv[p+1]);
                     sprintf (file,"~"DEVMAPS"cdata/map%02i.wad", p);
	                 lfprintf("Warping to Map %02i.\n", p);
                    }
	             break;
	       }
        if (strlen(file) > 0)
           {
	        D_AddFile(file);
           }
       }
	
    p = M_CheckParm ("-file");
    if (p)
       {
        if (gamemode == shareware)
           {
            con_printf("\nYou cannot -file with the shareware version. Register!\n\n");
           }
        else
           {
	        // the parms after p are wadfile/lump names,
	        // until end of parms or another - preceded parm
	        modifiedgame = true;            // homebrew levels
	        while (++p != myargc && myargv[p][0] != '-')
               {
                D_AddFile (myargv[p]);
               }
           }
       }

    p = M_CheckParm ("-playdemo");
    if (!p)
       {
        p = M_CheckParm ("-playdemo2");
        demotype = DEMO_II;
       }
    else
       {
        demotype = DEMO_I;
       }

    if (!p)
       {
	    p = M_CheckParm ("-timedemo");
        demotype = DEMO_I;
       }

    if (!p)
       {
	    p = M_CheckParm ("-timedemo2");
        demotype = DEMO_II;
       }

    if (p && p < myargc-1)
       {
        if (demotype == DEMO_I)
           {
	        sprintf (file,"%s.lmp", myargv[p+1]);
	        D_AddFile (file);
	        con_printf("Playing demo %s.lmp.\n",myargv[p+1]);
           }
        else
           {
	        con_printf("Playing demo II %s.dem.\n",myargv[p+1]);
           }
       }
    
    // get skill / episode / map from parms
    startskill = sk_medium;
    startepisode = 1;
    startmap = 1;
    autostart = false;
		
    p = M_CheckParm ("-skill");
    if (p && p < myargc-1)
       {
 	    startskill = myargv[p+1][0]-'1';
	    autostart = true;
       }

    p = M_CheckParm ("-episode");
    if (p && p < myargc-1)
       {
        startepisode = myargv[p+1][0]-'0';
        startmap = 1;
        autostart = true;
       }
	
    p = M_CheckParm ("-frags");
    if (p && p < myargc-1 && deathmatch)
       {
	    int     frags;
	    frags = atoi(myargv[p+1]);
	    con_printf("Levels will end after %d frag",frags);
	    if (frags > 1)
           {
	        con_printf("s");
           }
	    con_printf(".\n");
       }

    p = M_CheckParm ("-timer");
    if (p && p < myargc-1 && deathmatch)
       {
	    int     time;
	    time = atoi(myargv[p+1]);
	    con_printf("Levels will end after %d minute",time);
	    if (time>1)
           {
	        con_printf("s");
           }
	    con_printf(".\n");
       }

    p = M_CheckParm("-nosound");
    if (p != 0)
       {
	    con_printf("Sound disabled.\n");
        nosound = true;
        nosound_t = true;
       }

    p = M_CheckParm ("-avg");
    if (p && p < myargc-1 && deathmatch)
	{
	    lfprintf("Austin Virtual Gaming: Levels will end after 20 minutes\n");
	}

    //10.15.98 dlw Score keeping command lines now added
    keepscore = 0;
    showscoreHUD = 0;
    keepscore = M_CheckParm("-keepscore");

    //10.15.98 dlw Score showing adds keeping by default
    p = M_CheckParm("-showscore");
    if (p)
    {
        showscoreHUD = 1;
        keepscore = 1;
    }

    p = M_CheckParm ("-warp");
    if (p && p < myargc-1)
       {
	    if (gamemode == commercial)
           {
            if (((myargv[p+1][0] >= '0') && (myargv[p+1][0] <= '9')) &&
                (((myargv[p+1][1] >= '0') && (myargv[p+1][1] <= '9')) || (myargv[p+1][1] == '\0')))
               {
                startmap = atoi(myargv[p+1]);
                if ((startmap > 0) && (startmap < 33))
                   {
                    autostart = true;
                   }
                else
                   {
                    startmap = 1;
                   }
               }
           }
        else
           {
            if (((myargv[p+1][0] >= '1') && (myargv[p+1][0] <= '4')) &&
                ((myargv[p+2][0] >= '1') && (myargv[p+2][0] <= '9')))
               {
                startepisode = myargv[p+1][0]-'0';
                startmap = myargv[p+2][0]-'0';
                if (((gamemode == retail) && (startepisode < 5)) ||
                    ((gamemode == registered) && (startepisode < 4)) ||
                    ((gamemode == shareware) && (startepisode == 1)))
                   {
                    autostart = true;
                   }
                else
                   {
                    startmap = 1;
                    startepisode = 1;
                   }
               }
           }
        if (autostart != true)
           {
            con_printf("Invalid start map requested...\n");
           }
       }

    
    // init subsystems
    //printf ("V_Init: allocate screens.\n");
    con_printf("V_Init: allocate screens.\n");
    V_Init ();

    //printf ("Z_Init: Init zone memory allocation daemon. \n");
    con_printf("Z_init: Init zone memory allocation daemon. \n");
    Z_Init ();

    //printf ("W_Init: Init WADfiles.\n");
    con_printf("W_Init: Init WADfiles.\n");
    W_InitMultipleFiles(wadfiles);
    
    if (CheckGameMode() == false)
       {
        con_printf("Unable to determine game mode - aborting...\n");
        return;
       }


    if (W_CheckNumForName("DEMO1") != -1)
       {
        demover = (byte *)W_CacheLumpName("DEMO1", PU_CACHE);
        if (*demover != 109)
           {
            con_printf("+---------------------------------------------------------------+\n");
            con_printf("|      B A D   D E M O   V E R S I O N   D E T E C T E D !      |\n");
            con_printf("+---------------------------------------------------------------+\n");
            if (modifiedgame)
               {
                con_printf("|       This wad contains demos from a version %d.%d WAD.         |\n", *demover/100,*demover%100);
               }
            else
               {
                con_printf("|       This wad appears to be from a version %d.%d WAD.          |\n", *demover/100,*demover%100);
               }
            con_printf("|     You are advised that this may not run and the demos       |\n");
            con_printf("|     may not play even if it does run.  glDoom will NOT        |\n");
            con_printf("|     work properly on WAD versions earlier than 1.9            |\n");
            con_printf("+---------------------------------------------------------------+\n");
           }
       }

    switch ( gamemode )
       {
        case retail:
             sprintf (title, "                     The Ultimate DOOM Startup v%i.%i",VERSION/100,VERSION%100);
             break;
        case shareware:
             sprintf (title, "                      DOOM Shareware Startup v%i.%i", VERSION/100,VERSION%100);
             break;
        case registered:
             sprintf (title, "                     DOOM Registered Startup v%i.%i", VERSION/100,VERSION%100);
             break;
        case commercial:
             if (plutonia == true)
                 sprintf (title, "                   DOOM 2: Plutonia Experiment v%i.%i", VERSION/100,VERSION%100);
             else
             if (tnt == true)
                 sprintf (title, "                     DOOM 2: TNT - Evilution v%i.%i", VERSION/100,VERSION%100);
             else
                 sprintf (title, "                      DOOM 2: Hell on Earth v%i.%i", VERSION/100,VERSION%100);
             break;
        default:
             sprintf (title,"                     Public DOOM - v%i.%i",VERSION/100,VERSION%100);
           break;
       }
    
    con_printf("%s\n",title);

    // Check for -file in shareware
    if (modifiedgame)
       {
       // These are the lumps that will be checked in IWAD,
       // if any one is not present, execution will be aborted.
       char name[23][8]= { "e2m1","e2m2","e2m3","e2m4","e2m5","e2m6","e2m7","e2m8","e2m9",
          "e3m1","e3m3","e3m3","e3m4","e3m5","e3m6","e3m7","e3m8","e3m9",
          "dphoof","bfgga0","heada1","cybra1","spida1d1" };
       int i;
       
       if (gamemode == shareware)
          {
           I_Error("\nYou cannot -file with the shareware version. Register!\n\n");
          }
       
       // Check for fake IWAD with right name,
       // but w/o all the lumps of the registered version. 
       if (gamemode == registered)
          for (i = 0;i < 23; i++)
             if (W_CheckNumForName(name[i])<0)
                I_Error("\nThis is not the registered version.");
       }
    
    // If additonal PWAD files are used, print modified banner
    if (modifiedgame)
       {
       con_printf("===========================================================================\n");
       con_printf("ATTENTION:  This version of DOOM has been modified.  If you would like to\n");
       con_printf("get a copy of the original game, call 1-800-IDGAMES or see the readme file.\n");
       con_printf("        You will not receive technical support for modified games.\n");
       //con_printf("                      press enter to continue\n");
       con_printf("===========================================================================\n");
       //    );
       //getchar ();
       }
    
    
    if ((conversion == true) && (gamemode != undetermined))
       {
       con_printf("===========================================================================\n");
       con_printf("                              Full Conversion!\n");
       con_printf("===========================================================================\n");
       }
    else
       {
       // Check and print which version is executed.
       switch ( gamemode )
          {
          case shareware:
             //case undetermined:
             //printf (
             con_printf("===========================================================================\n");
             con_printf("                                Shareware!\n");
             con_printf("===========================================================================\n");
             //);
             break;
          case registered:
          case retail:
          case commercial:
             //printf (
             con_printf("===========================================================================\n");
             con_printf("                 Commercial product - do not distribute!\n");
             con_printf("         Please report software piracy to the SPA: 1-800-388-PIR8\n");
             con_printf("===========================================================================\n");
             //);
             break;
          case undetermined:
             con_printf("===========================================================================\n");
             con_printf("                  Unable to determine game mode - aborting\n");
             con_printf("===========================================================================\n");
             break;
          default:
             // Ouch.
             break;
          }
       
       }

    CreateGLPalette();

    //printf ("M_Init: Init miscellaneous info.\n");
    con_printf("M_Init: Init miscellaneous info.\n");
    M_Init();

    //printf ("R_Init: Init DOOM refresh daemon - ");
    con_printf("R_Init: Init DOOM refresh daemon - ");
    R_Init();

    //printf ("\nP_Init: Init Playloop state.\n");
    con_printf("\nP_Init: Init Playloop state.\n");
    P_Init();

    //con_printf("WS_Init: Init weapon sprites.\n");
    //WS_Init();

    con_printf("WS_Init: Init sprites - ");
    LoadAllSprites();

    //printf ("I_Init: Setting up machine state.\n");
    con_printf("I_Init: Setting up machine state.\n");
    I_Init();

    //printf ("D_CheckNetGame: Checking network game status.\n");
    con_printf("D_CheckNetGame: Checking network game status.\n");
    D_CheckNetGame();
    if (gamemode == netabort)
       {
        return;
       }

    //printf ("S_Init: Setting up sound.\n");
    con_printf("S_Init: Setting up sound.\n");
    //S_Init (snd_SfxVolume*8, snd_MusicVolume*8 );
    S_Init(snd_SfxVolume, snd_MusicVolume );

    con_printf("HU_Init: Setting up heads up display.\n");
    HU_Init();

    con_printf("ST_Init: Init status bar.\n");
    ST_Init();

    con_printf("CO_Init: Init console.\n");
    CO_Init();

    con_printf("WI_Init: Init game widgets.\n");
    WI_Init();

    con_printf("F_Init: Init game finale.\n");
    F_Init();

    // check for a driver that wants intermission stats
    p = M_CheckParm ("-statcopy");
    if (p && p<myargc-1)
       {
       // for statistics driver
       extern  void*	statcopy;                            
       
       statcopy = (void*)atoi(myargv[p+1]);
       //printf ("External statistics registered.\n");
       con_printf("External statistics registered.\n");
       }
    
    // start the apropriate game based on parms
    p = M_CheckParm ("-record");
    if (p && p < myargc-1)
       {
       G_RecordDemo (myargv[p+1]);
       autostart = true;
       }
    
    p = M_CheckParm ("-playdemo");
    if (p && p < myargc-1)
       {
       singledemo = true;              // quit after one demo
       G_DeferedPlayDemo (myargv[p+1]);
       return;
       //    D_DoomLoop ();  // never returns
       }
    
    p = M_CheckParm ("-playdemo2");
    if (p && p < myargc-1)
       {
       singledemo = true;              // quit after one demo
       if (G_DeferedPlayDemo_II(myargv[p+1]) == true)
          return;
       else
          {
          con_printf("DEMO II [%s.dem] - BAD FILE.\n", myargv[p+1]);
          }
       //    D_DoomLoop ();  // never returns
       }
    
    p = M_CheckParm ("-timedemo");
    if (p && p < myargc-1)
       {
       con_printf("-timedemo\n");
       G_TimeDemo (myargv[p+1]);
       return;
       //    D_DoomLoop ();  // never returns
       }
    
    p = M_CheckParm ("-timedemo2");
    if (p && p < myargc-1)
       {
       con_printf("-timedemo2\n");
       if (G_TimeDemo_II(myargv[p+1]) == true)
          return;
       else
          {
          con_printf("DEMO II [%s.dem] - BAD FILE.\n", myargv[p+1]);
          }
       //    D_DoomLoop ();  // never returns
       }
    
    p = M_CheckParm ("-loadgame");
    if (p && p < myargc-1)
       {
       if (M_CheckParm("-cdrom"))
          sprintf(file, "c:\\doomdata\\"SAVEGAMENAME"%c.dsg",myargv[p+1][0]);
       else
          sprintf(file, SAVEGAMENAME"%c.dsg",myargv[p+1][0]);
       G_LoadGame (file);
       }
    
    if ( gameaction != ga_loadgame )
       {
       if (autostart || netgame)
          G_InitNew (startskill, startepisode, startmap);
       else
          D_StartTitle ();                // start up intro loop
       
       }
    loadtime = I_GetTime();
    //    D_DoomLoop ();  // never returns
}
